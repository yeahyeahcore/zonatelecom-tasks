# О задании

Задание содержит 4 секции, из которых обязательной является только первая. Реализуйте как можно больше секций и как можно больше необязательных требований (приоритет между секциями и необязательными требования выбирайте самостоятельно). Секция засчитывается, если все ее обязательные требования реализованы и реализованы все предыдущие секции. 

## Предыстория

Вы работаете в команде, занимающейся автоматизацией системы обработки онлайн голосований для телевидения, радио и других медиа. Ваш коллега реализует сервис Альфа, который должен получать оценки голосования из разных источников и передавать их в сервис Бета, который предстоит разработать вам. Ваш сервис Бета отвечает за поддержание и передачу текущего состояния каждого голосования в сервис Гамма, а также за сохранение всей истории полученных оценок в базу данных.

## Требования к выполнению задания и коду:

1. Решение задачи должно быть реализовано одним сервисом
2. Допускается использование внешних библиотек для совместной компиляции с сервисом
3. Не допускается опираться на использование внешних систем, не описанных в задании (кеширующих серверов, брокеров сообщений и т.п.)
4. Исходный код должен быть сохранен под git и передан архивом или ссылкой на публичный репозиторий с общедоступной историей внесения правок.

## Секция 1

### **Функциональные требования**:

1 - Принимать оценки от сервиса Альфа по REST методу `http://service-beta/voting/` с `body(json)`: 

```
{
  "voteId": "#{128-bit-guid}",  
  "votingId": "#{128-bit-guid}", 
  "optionId": "#{128-bit-guid}"
}

Ответ 200:

{
  “result”:”ok”
}

формировать немедленно, не дожидаясь обработки. 

Поля запроса:

voteId - уникальный идентификатор голоса
votingId - уникальный идентификатор голосования
optionId - уникальный идентификатор варианта голосования
```

2 - формировать текущее состояние каждого голосования и отправлять его в сервис `Гамма`:.

```
Состояние голосования - это идентификатор голосования и количество голосов в разрезе вариантов голосования
отправлять в сервис Гамма по REST методу http://service-gamma/voting-stats/ с body(json): 

{ 
  "votingId" : "#{128-bit-guid}", 
  results: [ 
    {
      "optionId":"#{128-bit-guid}", 
      "count": 176
    }, 
    {
      "optionId":"#{128-bit-guid}", 
      "count": 283
    } 
  ] 
}

где count - это количество голосов за вариант.

Отправка состояния голосования должна происходить только в момент, когда целочисленная часть процентного соотношения хотя бы одного из вариантов голосования изменится (например, с 45.9% на 46.3%), но не более двух раз в секунду
```

3 - сохранять голоса в реляционную базу данных. Конкретную СУБД и структуру данных выбирайте самостоятельно

### **Нефункциональные требования:**
- Целевая нагрузка 5000rps
- Обработка ошибок и логирование обязательны
- Реализация graceful shutdown обязательна
- Покрытие тестами желательно
- Хранение кредов к БД в vault желательно
- Встраивание распределенной трассировки желательно, выбор инструмента на вас
- Хэлс чеки желательны

## Секция 2

Вы выяснили, что:

- В силу ограничений хранилища данных производительность обработки запросов вставки СУБД - 100rps в рамках одного соединения, вне зависимости от размера запроса (количества элементов для вставки в рамках запроса)
- Максимальное количество параллельных соединений к СУБД - 6
- Время установления нового соединения с СУБД равно 2 секундам
- Соединения периодически перестают работать (не чаще одного раза в 10 секунд), но в каждый момент времени доступно не менее пяти рабочих подключений к СУБД

Доработайте систему с учетом этих ограничений


## Секция 3

В систему стали попадать поддельные голоса, вам необходимо отбрасывать такие голоса при приеме. Для этого сервис Альфа вместе с каждым голосом будет присылать в ваш сервис Бета электронную подпись. К сожалению, вам не известен алгоритм проверки подписи в силу его проприетарности и для этого вам необходимо обращаться в сервис Digest, который возьмет всю проверку на себя. Ответ сервису Альфа теперь нужно отдавать только по результату проверки подписи

```
1) формат голоса для сервиса http://service-beta/voting/ становится  json 

{ 
  "voteId": "#{128-bit-guid}",  
  "votingId": "#{128-bit-guid}", 
  "optionId": "#{128-bit-guid}", 
  “digest”: “#{128-bit-HEX}”
}

2) Сервис Digest предоставляет метод POST http://service-digest/check, принимающий в body голос в том же формате, в котором он пришел от сервиса Alpha. Ответ сервиса: 

{
  “result”:”ok”
} 

или 

{
  “result”:”fail”
} 

в зависимости от результата проверки. Производительность сервиса Digest 6000rp2s, но не более 500 одновременных запросов

3) Ответ вашего сервиса Beta http://service-beta/voting/ сервису Alpha:

Status code 200: 

{
  “result”:”ok”
}, 

если электронная подпись корректная

Status code 400: 

{
  “result:”fail”, 
  “message”: “Wrong digest”
}, 

если электронная подпись некорректная
```

## Секция 4

К сожалению, дедлайн близок, а в сервисе Альфа была обнаружена ошибка, которая приводит к периодической отправке некорректных оценок, по которым позднее приходят корректировки с теми же votingId и voteId, но другими optionId и digest . Исправление ошибки в сервисе Альфа до дедлайна оказалось невозможным и предотвращение сохранения в СУБД неверных оценок приняли решение временно делать в сервисе Бета. Известно, что корректирующий голос по ошибочным из сервиса Альфа приходит в течении 2 минут, если корректирующего голоса в течении этого времени не пришло, значит первый голос был корректным.
Обеспечьте отсутствие некорректных голосов в СУБД в любой момент времени. Отправку временно некорректных данных в сервис Гамма допустима и в этой интеграции ничего переделывать не нужно, состояние голосования все также должно обновляться сразу после поступления данных с учетом ограничений сервиса Гамма, описанных в первой секции (без дополнительных двухминутных задержек), но корректирующий голос должен откорректировать и общие результаты голосования для сервиса Гамма

# КОНЕЦ ЗАДАНИЯ
